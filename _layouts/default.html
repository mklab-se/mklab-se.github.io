---
---
<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: 'en' }}">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{% if page.title %}{{ page.title }} Â· {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
  <meta name="description" content="{{ page.description | default: site.description }}" />
  {% if page.meta_image or site.meta_image %}
  {% assign og_image = page.meta_image | default: site.meta_image %}
  <meta property="og:image" content="{{ og_image | absolute_url }}" />
  <meta name="twitter:image" content="{{ og_image | absolute_url }}" />
  {% endif %}
  <link rel="stylesheet" href="{{ '/assets/css/site.css' | relative_url }}" />
  <link rel="icon" href="{{ '/favicon.ico' | relative_url }}" />
  {% if page.head_extra %}{{ page.head_extra }}{% endif %}
</head>
<body class="{{ page.body_class | default: '' }}">
  {% unless page.hide_header %}
    {% include site-header.html %}
  {% endunless %}

  {{ content }}

  {% unless page.hide_footer %}
    {% include site-footer.html %}
  {% endunless %}

  <script>
    const yearTargets = document.querySelectorAll('[data-current-year]');
    const currentYear = new Date().getFullYear();
    yearTargets.forEach(el => { el.textContent = currentYear; });

    const revealElements = document.querySelectorAll('.reveal');
    if ('IntersectionObserver' in window) {
      const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('is-visible');
            observer.unobserve(entry.target);
          }
        });
      }, { threshold: 0.15 });
      revealElements.forEach(el => observer.observe(el));
    } else {
      revealElements.forEach(el => el.classList.add('is-visible'));
    }

    // Streaming text animation
    const streamingElements = document.querySelectorAll('[data-stream]');
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    let globalWordIndex = 0;
    streamingElements.forEach((el, elIndex) => {
      const text = el.textContent.trim();
      const words = text.split(/\s+/);
      const baseDelay = parseInt(el.dataset.streamDelay || '0', 10);
      el.innerHTML = '';

      words.forEach((word, i) => {
        const span = document.createElement('span');
        span.className = 'word';
        span.textContent = word;
        if (!prefersReducedMotion) {
          // Stagger based on global word count for sequential animation
          span.style.animationDelay = `${(globalWordIndex + i) * 0.04}s`;
        }
        el.appendChild(span);
        // Add space after each word except the last
        if (i < words.length - 1) {
          el.appendChild(document.createTextNode(' '));
        }
      });
      globalWordIndex += words.length;
    });
  </script>
</body>
</html>
